```c++
class DBConnection{
public:
	static DBconnection create();
	void close();
};
```

이런식으로 DBConnection이 구성되어 있다면, 사용자가 close()를 직접 호출 해야 하는 설계가 됩니다. 직접 호출을 사전에 차단하기 위한 방법으로 소멸자에서 close()를 호출하는 방법이 있는데.

```c++
class DBConnection{
public:
	~DBConn()
	{
		db.close();
	}
private:
	DBConnection db;
}

{
	DBConn dbc(DBConnection::create()); 
	// 객체 생성후, DBConn 객체가 관리

} // 여기서 DBConn 객체가 소멸되면서 소멸자 자동으로 호출
```

close 호출을 제대로 설공하면 아무 문제될 것이 없는 코드지만
close에서 예외가 발생하면 예외가 전파되어 정의되지 않은 동작에 이를 수 있다.
이런 불상사를 피하기 위한 2가지로
- close에서 예외가 발생하면 프로그램을 바로 끝낸다. 대게 abort를 호출
	```c++
	DBConn::~DBConn()
	{
		try { db.close(); }
		catch (...)
		{
			//close 호출이 실패했다는 로그 작성
			std::abort();
		}
	}
	```
예외를 흘러보내지 않고, abort를 호출해서 예외 전파를 막는다

- close를 호출한 곳에서 일어난 예외를 삼켜버리기
	```c++
	DBConn:~DBConn()
	{
		try { db.close();}
		catch (...){
			// close 호출이 실패했다는 로그를 작성.
		}
	}
	```
대부분의 경우 예외 삼키기는 좋은 발상이 아니다. 무엇이 잘못됐는지를 알려주는 정보가 묻혀버리기 때문인데, 하지만 때에 따라서는 불완전한 프로그램 종료 혹은 미정의 동작으로 인해 입는 위험을 감수하기 보다 그냥 예외를 먹는게 더 나을 수도 있다. 
하지만 '예외 삼키기'를 선택한 것이 제대로 빛을 보려면, 발생한 예외를 그냥 무시한 뒤라도 프로그램이 신뢰성 있게 실행을 지속 할 수 있어야 한다.

하지만 어느쪽도 소멸자에서 던진 에러에 대해 프로그램이 어떤 조치를 취할 수 있는가? 에 대해서는 대책이 없기 떄문에 좋은 방식은 아닌데. 소멸자 말고 사용자에게 책임을 전가할 수 있다.

DBconn에서 Close 함수를 직접 제공 하면서 
DBConnection이 닫혔는지 유지 헀다가, 닫히지 않았다면 DBConn 의 소멸자에서 닫을 수 있다. 만약 소멸자에서 호출하는 db.close() 마저 실패했다면 위의 2가지 방법중에 하나를 사용할 수 밖에 없지만 사용자가 직접 사용하지 않아 발생하는 예외는 **"소멸자가 아닌 다른 함수에서 비롯된 것"** 이기 때문에 에러를 처리할 수 있는 기회가 있다.

```c++
class DBConn
public:
	void close()
	{
		db.close();
		closed = true;
	}
	~DBConn()
	{
		if(!closed)
		try{
			db.close();
		}
		catch(...){
			// close 호출이 실패했다는 로그 작성
		}
	}
private:
	DBConnection db;
	bool closed;
```

예외를 소멸자에서 발생하지 않게끔 1차 보험을 드는 것은 물론이고
소멸자에서 발생하더라도, 전파되지 않게 "삼켜 버리거나", "Abort" 등의 방법을 사용해 적절하게 사용자에게 책임을 전가한다는데 핵심이 있다.
**소멸자에서 예외를 발생하지 않게끔** 하는게 중요한 포인트인 것 같다.

# 이것만은 잊지 말자!
- 소멸자에서는 예외가 빠져나가면 안된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜버리던지, 프로그램을 끝내던지 해야합니다.
- 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수) 이어야 한다.