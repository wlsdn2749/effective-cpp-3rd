
어떤 함수를 파생시키려고 한다.
```c++
class TimeKeeper{
public:
	TimeKeeper();
	~TimeKeeper();
	TimeKeeper* getTimeKeeper(){
		return *this;
	}
};

class AtomicClock: public TimeKeeper {};
class WaterClock: public TimeKeeper {};
class WristClock: public TimeKeeper {};

TimeKeeper *ptr = getTimeKeeper();
//
delete ptr;
```
문제는 
- `getTimeKeeper` 함수가 반환하는 포인터가 파생 클래스 객체에 대한 포인터라는 점
- 이 포인터가 가리키는 객체가 삭제될 때는 기본 클래스 포인터 (TimeKeeper* 포인터)를 통해 삭제 된다는 점
- 그리고 결정적으로 기본 클래스 (TimeKeeper)에 달어있는 소멸자가 비가상 소멸자라는 점이다.

C++의 규정에 의하면, 기본 클래스 포인터를 통해 파생 클래스 객체가 삭제될 때 그 기본 클래스에 비가상 소멸자가 들어있으면 프로그램 동작은 미정의 사항이라고 되어있다.

`getTimeKeeper` 함수에서 포인터를 통해 날아오는 `AtomicClock` 객체는 기본 클래스 포인터를 통해 삭제 될 때 `AtomicClock` 부분의 데이터 멤버의 소멸자도 실행되지 않을 뿐더러 `AtomicClock` 객체의 소멸자도 실행되지 않는다. 그러나 `TimeKeeper` 부분의 소멸자는 실행되므로 부분 소멸 상태에 이르게 된다.
- 자원 누수 발생
- 자료구조 오염, 디버그 필요

문제를 없애기 위해 기본 클래스의 소멸자에 `virtual` 키워드를 붙여주면 해결된다
파생 클래스 객체를 기본 클래스 포인터로 삭제하려고 하면, 객체 전부가 소멸된다. 
파생클래스 부분도 삭제됨
```c++
class TimeKeeper{
public:
	TimeKeeper();
	virtual ~TimeKeeper();
};

TimeKeeper *ptk = getTimeKeeper();
...
delete ptk;
```

TimeKeeper 비슷한 기본 클래스에는 소멸자외에도 가상 멤버 함수가 더러 들어있게 되는데,
가상함수를 하나라도 가진 클래스는 가상 소멸자를 가지는게 대부분 맞다.

가상 소멸자를 갖고 있지 않은 클래스를 만나면
"아, 저 클래스는 기본 클래스로 쓰일 의지를 상실 한 것이구나"

반대로 기본 클래스로 의도하지 않은 클래스에 대해 소멸자를 가상으로 선언하는 것은 좋지 않다
```c++
class Point{
public:
	Point(int xCoord, int yCoord);
	~Point();

private:
	int x, y;
};
```

int가 32비트를 차지한다고 가정하면 이 포인트 객체는 64비트 레지스터에 딱 맞게 들어가는데,  Point 클래스에 소멸자가 가상 소멸자로 만들어지는 순간, 문제가 생긴다.

가상 함수를 C++에서 구현하려면 별도의 자료구조가 하나 들어가는데 이 자료구조는 프로그램 실행 중에 주어진 객체에 대해 어떤 가상 함수를 호출해야 하는지를 결정하는데 쓰이는 정보이다.
실제로는 포인터의 형태를 취하는 것이 대부분이고, 대개 `vptr`이라는 이름으로 불린다.

vptr은 가상 함수의 주소인, 포인터들의 배열을 가리키고 있으며 
vtb1은 가상 함수 포인터 배열인데, 가상 함수를 하나라도 갖고 있는 클래스는 반드시 그와 관련된 vtb1을 갖고 있다. 어떤 객체에 어떤 함수가 호출되려고 하면, 호출되는 실제 함수는 그 객체의 vptr이 가리키는 vtb1에 따라 결정되고, vtb1에 있는 함수 포인터들 중 적절한 것이 연결된다.

Point 클래스에 가상 함수가 들어가게 되면 프로그램 실행환경이 32비트라면
64(int 2개) + 32(vptr 하나)로 96비트가 되고, 64비트라면 64(int 2개) + 64(vptr 하나)로 128비트가 된다.
가상 함수 포인터가 하나 추가됬을 뿐인데, 크기가 50~100% 가량 커지게 되는 일이 발생한다.

어느 경우를 막론하고 소멸자를 전부 virtual로 선언한은 일은 virtual로 절대 선언하지 않는 것 만큼이나 안좋은 마인드이다. _**가상 소멸자를 선언하는 경우에는 그 클래스에 가상함수가 하나라도 들어있는 경우에만 한정하는게 좋다.**_ 

가상 함수가 전혀 없는데도 비가상 소멸자 때문에 문제가 생기는 경우도 있는데
한 예시가 표준 string 타입이다. 이 타입은 가상 함수를 갖고 있지 않지만 이 함수를 기본 클래스로 잡아버리는 경우가 있는데
```c++
class SpecialString: public std::string{ // std::string은 가상 소멸자가 없다!
};
```

위에 비가상 소멸자를 기본클래스로부터 파생시킨 결과가 나타난다
SpecialString의 포인터를 string 포인터로 어떻게든 변환한 후에 그 string 포인터에
delete를 적용하면 정의되지 않은 동작이 발생하는데
실제로는 SpecialString의 소멸자가 동작하지 않으므로, 이 부분에 대한 자원 누수가 발생하고 만다.

경우에 따라서는 순수(pure) 가상 소멸자를 두면 편리하게 사용할 수 있다.
어떤 클래스가 추상 클래스였으면 좋겠는데 마땅히 넣을 만한 순수 가상 함수가 없을때도 종종 생기는데. 
추상 클래스는 원래 기본 클래스로 쓰일 목적으로 만들어진 것이고
기본 클래스로 쓰이려는 클래스는 가상 소멸자를 가져야 하니까

순수 가상 함수가 있으면 바로 추상 클래스가 된다.
= **추상 클래스로 만들고 싶은 클레스에 순수 가상 소멸자를 선언하는 것**
```c++
class AWOV{
public:
	virtual ~AWOV() = 0; // 순수 가상 소멸자를 선언
}
```

이 순수 가상 소멸자의 정의를 두어야 한다.
-> 소멸자는 상속 계통 구조에서 가장 말단부터 기본 클래스까지 쭉 올라오게 되는데 기본 클래스의 소멸자가 선언만 되어있고 정의가 되어있지 않으면 링커에러를 보게됨.

또한 이 순수 가상 함수를 상속하여 만든 파생 클래스는
반드시 소멸자를 override하여 선언해야한다.

# 이것만은 잊지 말자!
- 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야한다. 즉 어떤 클래스가 가상 함수를 하나라도 가지고 있으면, 이 클래스의 소멸자도 가상 소멸자이어야 한다.
- 기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야한다.