자기대입이란 어떤 객체가 자기 자신에 대해 대입 연산자를 적용하는 것을 말한다.
```c++
class Widget { ... };

Widget w;
...

w = w; // 자기에 대한 대입
```

이렇게 적나라하게 코드를 작성하는일은 거의 없겠지만

```c++
a[i] = a[j]; // 이거나
*px = *py ; // 이거나 하는 코드는 자기대입의 가능성이 높지만, 찾기 힘들 수 있다.
```

자원 관리 용도로 객체를 생성할 것이고, 이렇게 만든 자원 관리 객체들이 복사될 때 나름대로 잘 동작하도록 해야하는데 이때 특히 조심해야할 것이 대입 연산자이다.

대입 연산자에서는 신경 쓰지 않아도 자기대입에 대해 안전하게 동작해야 하는데.
가령 자원을 사용하기전에 해제해버린다면 어떤 결과가 발생할까?
```c++
class Bitmap{};
class Widget{
public:
	Widget& operator=(const Widget& rhs);
private:
	Bitmap *pb;
}

Widget& Widget::operator=(const Widget& rhs)
{
	delete pb;
	pb = new Bitmap(*rhs.pb);
	return *this;
}
```

여기서 rhs와 \*this가 다른 객체일 때는, 문제가 없지만 같은 객체인 경우
pb를 삭제하는 과정에서 rhs의 pb도 덩달아 삭제되기 때문에, rhs의 포인터에서 pb를 참조할때 문제가 발생하게 된다.

전통적으로 자기자신에 대입 방지 방법으로 일치성 검사가 있는데
```c++
Widget& Widget::operator=(const Widget& rhs)
{
	if(this == &rhs) return *this;
	
	delete pb;
	pb = new Bitmap(*rhs.pb);
	return *this;
}
```

이렇게 하면 자기대입에 대한 문제가 해결되기야 하지만, 대입 연산자에는 예외에도 안전하지 않다는 점이 골치 아프게 한다.
가령`new Bitmap` 쪽에서 에러가 발생한다면, pb는 텅빈 객체를 가리키는 포인터가 되고 이를 호출하거나 하는 등의 문제가 발생할 소지가 있다.

다행스럽게도 `operator=`를 예외에 안전하게 구현하면 대개 자기대입에도 안전한 코드가 나오게 되어있다. "**많은 경우에 문장 순서를 세심하게 바꾸는 것만으로도 예외에 안전한(동시에 자기대입에 안전한) 코드가 만들어진다.**" 라는 법칙이 있다.

pb를 무턱대고 삭제하지말고, 이 포인터가 가리키는 객체를 복사한 직후에 삭제하면 해결 될 것 같다.
```c++
Widget& Widget::operator=(const Widget& rhs)
{
	Bitmap *pOrig = pb; // 원래의 pb를 어딘가에 기억해두고
	pb = new Bitmap(*rhs.pb); // pb가 *pb의 사본을 가리키게 만든다
	delete pOrig; // 그리고 원래의 pb를 삭제

	return *this; // 항목 10: 대입연산자는 항상 *this 참조를 반환
}
```

예외 처리만 했을 뿐인데, 자기 대입에 안전한 코드가 작성된다.

자기대입에 대한 예외처리를 빠르게하기 위해 일치성 검사를 제일 위에 놓을 수 있지만
자기대입이 그렇게 자주 일어나지 않는다고 한다면, 실행에 추가 비용이 드는 일치성 검사 코드를 작성하게 되면 실행 속력이 느려질 수 있을 뿐만 아니라, CPU 명령어 선행인출, 캐시, 파이프 라이닝의 효과도 덩달아 떨어질 수 있다.

마지막으로 예외 안전성과 자기대입 안정성을 동시에 가진 `operator=`를 구현하는 방법으로
복사 후 맞바꾸기라고 알려진 기법인데.

```c++
class Widget{
	void swap(Widget& rhs); // *this의 데이터와 rhs의 데이터를 맞바꾼다.
};

Widget& Widget::operator=(const Widget& rhs)
{
	Widget temp(rhs);
	swap(temp);
	return *this;
}
```
Widget의 사본을 하나 만들고, 그 사본과 교환하는 방법이다.
이 방법은 C++ 이 가진 2가지 특징을 활용해서 조금 다르게 구현할 수 있는데
- 클래스의 복사 대입 연산자는 인자를 값으로 취하도록 선언이 가능하다.
- 값에 의한 전달을 수행하면 전달된 대상의 사본이 생긴다는 점.

```c++
Widget& Widget::operator=(Widget rhs) // 값에의한 전달
{
	swap(rhs); // 생성된 사본과 *this의 데이터를 맞바꾼다.
	return *this;
}
```
결국 복사되는 대상의 사본을 만드는 것으로 해결하는데 여러방식이 있다고 볼 수 있다.

# 이것만은 잊지 말자!
- `operator=`를 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자. 
	- 원본 객체와 복사 대상 객체의 주소를 비교해도 되고
	- 문장의 순서를 적절히 조정할 수도 있으며,
	- 복사 후 맞바꾸기 기법을 써도 된다.
- 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인 해야한다.