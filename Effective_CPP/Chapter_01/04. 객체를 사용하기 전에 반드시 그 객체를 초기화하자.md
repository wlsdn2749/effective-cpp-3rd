
객체를 초기화 할 때 C++은 어떨때는 초기화 되거나 안될 수 있다.
C++ 객체 초기화에 규칙이 있기는 하지만, 규칙이 조금 복잡해서 이걸 알기에는 너무 복잡하다. 객체 초기화가 제대로 안되면 문제가 생기는데 정의되지 않은 동작이 그대로 흘러나온다는 점이다.
가장 좋은 방법은 객체를 사용하기 전에 항상 초기화 하는 것이다.

```c++
int x = 0; // int의 직접 초기화

const char * text = "A C-style string"; // 포인터의 직접 초기화

double d;

std::cin >> d; // 입력 스트림으로 읽음 으로써 "초기화" 수행
```

이런 부분을 제외하면 C++ 초기화의 나머지는 생성자로 귀결된다.
하지만, **대입**과 **초기화**를 헷갈리기 쉬운데


```c++
// 멤버 초기화 리스트

ABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones)

: theName(name),

theAddress(address),

thePhones(phones),

numTimesConsulted(0)

{}

  

// 초기화 아니고, 대입

ABEntry::ABEntry(const std::string& name, const std::string& address, const std::list<PhoneNumber>& phones)

{

theName = name;

theAddress = address;

thePhones = phones;

numTimesConsulted = 0;

}
```

멤버 초기화 리스트를 사용한 초기화는 대입하는 것보다 효율적일 가능성이 크다.
대입으로 초기화 하게 되면, 멤버변수를 기본 생성자로 초기화를 한 번 하고, 그다음에 대입하기 때문에 연산이 2번 일어나게 된다. 하지만 멤버변수 초기화는 대입없이 바로 복사생성자를 호출하기 때문에 효율적이다.

또한 기본제공 타입의 객체는 초기화와 대입에 걸리는 비용이 거의 차이가 없지만, 그래도 멤버 초기화 리스트에 모두 넣어주는 쪽이 좋다. 또 **_모든 데이터 멤버를 기본 생성자로 초기화하고 싶을 때도 멤버 초기화 리스트를 사용하는 습관_** 을 가지는게 좋다

```c++
ABEntry::ABEntry()
: theName(),
  theAddress(),
  thePhones(),
  numTimesConsulted(0)
{}
```

이렇게 기본제공 타입의 멤버를 초기화 리스트로 넣는 일이 선택이 아니라 의무가 될 때도 있는데 바로 상수와 참조자는 대입 자체가 불가능하므로 꼭 초기화로 해야한다.

C++에서의 객체 초기화는 꽤나 변덕스럽지만 객체를 구성하는 데이터의 초기화 순서는 어떤 컴파일러를 막론하고 항상 똑같다.
1. 기본 클래스는 파생 클래스보다 먼저 초기화 되고
2. 클래스 데이터 멤버는 그들이 선언된 순서대로 초기화된다.
	- 어쩌다가 선언된 순서대로 넣지 않아도, 초기화 순서는 그대로이다.
	- 코드를 읽는 다란 사람들의 혼동도 막고 찾아내기 힘든 동작 버그도 피하자는 의미에서 **_멤버 초기화 리스트에 넣는 멤버들의 순서도 클래스에 선언한 순서와 동일하게 맞춰 주도록 하자._**


## 비지역 정적 객체의 초기화 순서는 개별 번역 단위에서 정해진다.

**정적 객체(static object)** 는 자신이 생성된 시점부터 프로그램이 끝날 때 까지 살아있는 객체를 일컫는다. 그러니까 스택 객체 및 힙 기반 객체는 정적 객체가 될 수 없다.
- 전역 객체
- 네임스페이스 유효범위에서 정의된 객체
- 클래스 안에서 static으로 선언된 객체
- 함수 안에서 static 으로 선언된 객체
- 그리고 파일 유효범위에서 static으로 정의된 객체

이들 중 함수안에 있는 정적 객체는 **지역 정적 객체 (local static object)** 라고 하고
나머지는 **비지역 정적 객체(non-local static object)** 라고 한다.
이 객체는 모두 프로그램이 끝날때 자동으로 소멸된다. main() 함수의 실행이 끝날 때 정적 객체의 소멸자가 호출된다.

**번역 단위** 는 컴파일을 통해 하나의 목적 파일을 만드는 바탕이 되고, 기본적으로는 소스 파일 하나가 \#include 하는 파일들 까지 합쳐서 하나의 번역단위가 된다.

별도로 컴파일된 소스 파일이 두 개 이상 있으며, 각 소스 파일에 비지역 정적 객체가 한 개 이상 들어있는 경우에, 한쪽 번역 단위에 있는 비정적 객체의 초기화가 진행되면서 다른 쪽 번역 단위에 있는 비지역 정적 객체가 사용되는데, 불행히도 이 객체가 초기화되어 있지 않을지도 모른다는 점이다. (초기화 순서는 개별 번역 단위에서 정해지므로)

```c++
class FileSystem{
public:
	...
	std::size_t numDisks() const;
	...
};

extern FileSystem tfs; 

class Directory{
public:
	Directory (params)
	{
		std::size_t disks = tfs.numDisks();
	}
}

Directory tempDir(params); 
// 여기서 만약 FileSystem이 초기화되지 않은 상태에서 호출하게 된다면
// 문제가 발생한다! tfs가 null이 될 수도 있음
```

 어떻게 tfs를 Directory보다 먼저 초기화 되게 할 수 있을까?
서로 다른 번역 단위에 정의된 비지역 정적 객체들 사이에 
상대적인 초기화 순서는 정해져 있지 않다. -> 이거 정하기는 매우 어렵다.

하지만 비지역 정적 객체를 하나씩 맡는 준비하고 이 안에 각 객체를 넣으면 해결 할 수 있다.
함수 속에서 정적객체로 선언하고, 함수에서는 이 정적객체를 참조하는 참조자를 반환하게 하면 된다. (비지역 정적 객체 -> 지역 정적 객체)로 변경 \[SingleTon\]

지역 정적 객체는 함수 호출 중에 그 객체의 정의에 최초로 닿았을 때 초기화되도록 만들어져 있고, 이것은 C++에서 보장하는 사실이다.

```c++
class FileSystem { ... };

FileSystem& tfs()
{
	static FileSystem fs;
	return fs;
}

class Directory {...};

Directroy::Directory (params)
{
	...
	std::size_t disks = tfs().numDisks();
	...
}

Directroy& tempDir()
{
	static Directory td;
	return td;
}
```

이렇게 첫번째에서 지역 정적 객체를 정의하고, 두번째에서 리턴하면 끝으로 간단해서
`Inline` 화 해도될까 싶은데, 만약 멀티스레드 시스템에서 정적 객체를 사용하게 되면
장애가 생길 수 있다. Race Condition을 방지하기 위해서 프로그램이 다중 스레드로 돌입하기 전의 시동 단계에서 참조자 반환 함수를 전부 손으로 호출하는 방법도 있다.

물론 초기화 순서 문제를 방지하기 위해 이처럼 참조자 반환 함수를 사용하는 아이디어는, 객체들의 초기화 순서를 제대로 맞춰 둔다는 전제조건이 뒷받침 되어야 한다. 
만약 객체 A가 객체 B의 초기화에 의존하도록 만들어져 있다면, 문제가 될 수 있다.

# 이것만은 잊지 말자!
- 기본제공 타입의 객체는 직접 손으로 초기화하자. 경우에 따라 저절로 되기도 하고 안되기도 하기 때문
- 생성자에서는 데이터 멤버에 대한 대입문을 생성자 본문 내부에 넣는 방법으로 초기화하지말고 멤버 초기화 리스트를 즐겨 사용하자. 그리고 초기화 리스트에 데이터 멤버를 나열할 때는 클래스에 각 데이터 멤버가 선언된 순서와 똑같이 나열할 필요가 있다.
- 여러 번역 단위에 있는 비지역 정적 객체들의 초기화 순서는 피해서 설계해야 한다.
  비지역 정적 객체를 지역 정적 객체로 바꾸면 된다.

