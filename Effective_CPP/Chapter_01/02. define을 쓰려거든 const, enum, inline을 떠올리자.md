"가급적 선행 처리자보다 컴파일러를 더 가까이 하자". 라는 제목으로 가는 것도 좋았겠다 라고 한다.

만약 `#define ASPECT_RATIO 1.653` 이라는 코드를 작성했다고 한다면
컴파일러에게 넘어가기전에 `ASPECT_RATIO`라는 이름은 1.653으로 선행 처리자가 처리해 버려 1.653으로 모두 바뀌어 넘어가게 된다.

그 결과로 `ASPECT_RATIO`는 컴파일러가 쓰는 기호 테이블에 들어가지 않게 되고 만약 그 부분에서 컴파일 에러가 나게 된다면 1.653이라는 숫자로 대체되어 꽤나 헷갈릴 수 있게 된다.

특히 `ASPECT_RATIO`를 내가 작성한 코드가 아니라면 더욱 곤란해진다. 대체 1.653이 어디서 왔는지 모를 수 있고, 이것을 찾느라 시간을 허비할 일이 생길 수 있다.

이 문제의 해결법은 매크로를 사용하기보다 상수를 쓰는 것이다.
```c++
const double AspectRatio = 1.653; 
// 대문자로만 이름을 정하는건 대개 매크로에서만 쓰는 것이라 이름 표기도 바꿈
```

이렇게 상수로 **정의**하면 좋은점은 다음과 같다
1. \#define을 사용했을 때보다 최종코드의 크기가 작게 나올 수 있다.
   매크로를 사용하면 코드에 `ASPECT_RATIO`가 등장하기만 하면 선행 처리자에 의해 1.653으로 모두 바꿔면서 결국 목적 코드안에 1.653의 사본이 등장 횟수만큼 들어가지만, 상수 타입의 
   `AspectRatio`를 사용하게 되면 아무리 여러 번 쓰이더라도 사본은 딱 한 개만 생기기 때문이다.

2. 언어 차원에서 지원하는 상수 타입이므로 당연히 컴파일러의 눈에도 보이고, 기호 테이블에도 당연히 들어간다. 디버깅을 할 때 근원을 찾느라고 고생할 필요도 없으며 헷갈릴 여지를 줄여준다.

하지만 이렇게 상수로 교체하는데에도 2가지 경우의 조심할 부분이 있다.
1. 상수 포인터를 정의하는 경우
	- 상수 정의는 대개 헤더 파일에 넣는 것이 상례이므로 **포인터**는 꼭 const로 선언해 주어야 하고, 이와 아울러 포인터가 가리키는 대상까지 const로 선언하는 것이 보통이다.
	  이를 테면 어떤 헤더파일안에 char\* 기반의 문자열 상수를 정의한다면 const를 두번 써야한다
	  `const char* const authorName = "Scott Mayers";`
	  사실 const를 2번 쓰는것보다 string 객체가 대체적으로 더 사용하기 괜찮다
	  `const std::string authorName("Scott Meyers");`
2. 클래스 멤버로 상수를 정의하는 경우, 클래스 상수를 정의하는 경우
   어떤 상수의 유효범위를 클래스로 한정하고자 할 때는 그 상수를 멤버로 만들어야 하는데, 그 상수의 사본 개수가 한개를 넘지 못하게 하고 싶다면 **정적(static)** 멤버로 만들어야 한다.
	   
	```c++
	class GamePlayer{
	private:
		static const int NumTurns = 5; // 상수 선언 (정의가 아님)
		int scores[NumTurns];
	}
	```
	정적 멤버로 만들어지는 정수류(정수, char, bool) 타입의 클래스 내부 상수는 예외로 정의를해주지 않아도 된다. 단 클래스 상수의 주소를 구한다든지 할때는 정의를 해야한다
	
	`const int GamePlayer::NumTurns`는 NumTurns의 **정의** 부분인데
	클래스 상수의 정의는 구현 파일에 두고, 헤더파일은 두지 않는다.
	클래스 상수의 초기값은 해당 상수가 선언된 시점에서 바로 주어지기 떄문에 정의에는 상수 초기값이 있으면 안된다. 

오래된 컴파일러에서는 위와 같은 문법이 먹히지 않을 때가 있는데
헤더파일에서 변수만 정의하고, 구현부에서 값을 줌으로써 해결할 수 있다. 하지만 
만약 해당 클래스를 컴파일 하는 도중에 클래스 상수의 값이 필요할 때 문제가 되는데,
`GamePlayer::scores`라는 배열 멤버를 선언할때 `static const int` 의 정적 상수를 입력으로 줘야한다면 컴파일 에러가 날것이다. (구현부에서 값을 정의 하므로)

이때는 `enum {NumTurns = 5};`와 같은 나열자 둔갑술(enum hack) 이라는 통칭으로 알려진 기법을 생각할 수 있습니다. 이 기법의 원리는 나열자 타입의 값은 int가 놓일 곳에도 쓸 수 있다는 C++의 진실을 적극 활용하는 것입니다.

나열자 둔갑술에 대해 조금 더 알아보자면
1. 나열자 둔갑술은 동작방식이 const보다는 \#define에 가깝습니다. 
   const의 주소를 잡아내는 것은 합당하지만, enum의 주소를 취하는 것은 불법이며, \#define의 주소를 얻는 것 역시 맞지 않다. 이 정수상수를 다른 사람이 주소를 얻는다든지, 참조자를 쓴다든지를 막으려면 enum이 좋은 자물쇠가 될 수 있다.

2. 상당히 많은 코드에서 나열자 둔갑술이 쓰인다는 것
   나열자 둔갑술은 템플릿 메타프로그래밍의 핵심 기법이기도 하다.

\#define 선행 지시자의 또 다른 오용 사례는 매크로 함수이다.
함수처럼 보이지만 함수 호출 오버헤드를 일으키지 않은 매크로를 구현하는것.
매크로 인자들 중 큰 것을 사용해서 어떤 함수 f를 호출 하는 매크로이다.

```c++
// a와 b중에 큰 것을 f에 넘겨 호출
\#define CALL_WITH_MAX(a,b) f((a) > (b) ? (a) : (b))
```

이런 매크로를 작성할 떄는 매크로 본문에 들어 있는 인자마다 괄호를 씌워주어야 하는데, 그렇게 하지 않으면 골치 아픈 일이 벌어질 뿐만 아니라. 

```c++
int a = 5, b = 0;

CALL_WITH_MAX(++a, 0); // a가 두 번 증가
CALL_WITH_MAX(++a, b+10);  // a가 한 번 증가
```

`++a`는 한 번 호출하는데, 2번 증가하는 결과를 얻게 된다.

c++에서는 함수 호출을 없애 준다는 명목하에 자행되는 저런 어처구니 없는 코드를 짤 필요가 없다. 기존 매크로의 효율을 그대로 유지함은 물론, 정규 함수의 모든 동작방식 및 타입 안전성까지 완벽히 취할 수 있는 방법이 있다. 
**인라인 함수에 대한 템플릿** 으로 가능
```c++
template<typename T>
inline void callWithMax(const T& a, const T& b)
{
	f(a > b ? a : b);
}
```

이 함수는 템플릿 이기 때문에 Family of functions을 만들어낸다. 동일한 타입의 객체 두 개를 인자로 받고 둘 중 큰 것을 f에 넘겨서 호출하는 구조이다.
함수 본문에 괄호를 씌울 필요가 없고, 인자를 여러 번 평가할지도 모른다는 걱정도 사라지고 
`callWithMax`는 진짜 함수이기 때문에 유효범위 및 접근 규칙을 그대로 따라간다.
하지만 매크로 함수의 경우 이런 것을 전부 무시하므로 의미가 없다.

const, enum, inline의 사용으로 선행 처리자 특히 (\#define)을 사용하는 경우가 많이 줄긴 했지만 \#include는 지금도 사용하고 있고, \#ifdef/#ifndef도 컴파일 조정 기능으로 아주 잘 사용한다.

# 그래서! 이것만은 잊지 말자

- 단순한 상수를 쓸 때는, \#define보다 const객체 혹은 enum을 우선으로 생각
- 함수처럼 쓰이는 매크로를 만들려면, \#define 매크로보다 인라인 함수를 우선적으로 생각
