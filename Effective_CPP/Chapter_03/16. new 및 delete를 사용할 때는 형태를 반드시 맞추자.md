
아래의 예제에서 무언가 문제가 있다면?
```c++
std::string *stringArray = new std::string[100];
...
delete stringArray;
```

이런식으로 호출되게 되면 문제 없는 것 같지만, 프로그램은 미정의 동작으로 이르게 된다.
100개의 string 객체 가운데 가장 앞의 원소 말고는 나머지 99개의 소멸자가 불리지 않기 때문에, 정상적인 소멸과정을 거치지 못할 가능성이 크다

`new` 연산자를 사용해서 표현식을 꾸미게 되면 두 가지의 내부 동작이 진행된다.
1. 일단 메모리가 할당된다 `(operator new)`라는 이름의 함수가 쓰임
2. 그 다음 할당된 메모리에 대해 한 개 이상의 생성자가 호출된다.

마찬가지로 `delete` 연산자로 표현식을 쓰게 되면 똑같이 두 가지 내부 동작이 진행되는데
1. 기존에 할당된 메모리에 대해 한 개 이상의 소멸자가 호출되고
2. 그 후에 그 메모리가 해제된다. `(operator delete)` 라는 이름의 함수가 쓰인다.

delete 연산자가 적요되는 객체는, 소멸자가 호출되는 횟수와 같은데
위의 예제처럼 포인터를 삭제하게 되면, 이 포인터는 객체 하나를 가리키지 객체의 배열을 가리키지 않는다는 점에서
문제가 생긴다

new로 힙에서 만들어진 단일 객체의 메모리 구조가 객체 배열에 대한 메모리 배치구조와 다른데,
배열을 위해 만들어지는 힙 메모리에는 대개 배열 원소의 개수가 박혀들어간다는 점이 다르다.
이 때문에 delete 연산자는 소멸자가 몇 번 호출될지를 쉽게 알 수 있다.

반면 단일 객체용 힙 메모리에는 이런 정보가 없다.
그래서 배열을 가리키는 포인터를 삭제 하게되면 객체 하나만을 삭제하는 것이 되고
여기에 대괄호 쌍을 delete뒤에 붙여주게 되면, 그제서야 포인터가 배열을 가리키고 있다는 것을 알게되어 정상적으로 배열에 대해 소멸자를 호출 할 수 있게 된다

```c++
std::string *stringPtr1 = new std::string;
std::string *stringPtr2 = new std::string[100];

...
delete stringPtr1; // 객체 한 개를 삭제
delete[] stringPtr2; // 객체의 배열 삭제
```

만약 여기 stringPtr1 객체에 대해 delete [] 연산자를 사용하게 되면, 배열 삭제라고 인식하여, 앞의 몇바이트를 읽고 배열의 크기라고 생각한 후 삭제가 진행될 텐데,
메모리를 삭제하는 범위를 이상하게 잡거나, 그 범위를 넘어설 수 있는 치명적 문제가 생길 수 있고

stringPtr2 객체에 delete [] 연산자 대신 delete를 사용한다면, 배열에 비해 소멸자 호출 횟수가 너무 적어 이 또한 미정의 동작으로 빠지게 된다.

간단한 규칙 하나만 지키면 되는데
 - `new` 표현식에 [] 를 썼으면, 여기에 대응되는 `delete` 표현식에도 [] 를 써야한다는 규칙이다.
 - 반대로 `new` 표현식에 []를 안썼으면, `delete` 표현식에도 []를 쓰지 않아야 한다.

마지막으로 typedef의 경우에도 주의해야 하는데, `typedef std::string AddressLine[4];` 이렇게 적었다면 반드시 해제할때도 delete[] 형태가 되야 한다는 것이다.
하지만 이건 사용자 입장에서 헷갈릴 여지가 충분한데, 이런 경우 `typedef` 없이 코딩이 가능한 경우, `vector` 같은 것으로 정의 가능한 경우가 많은데, 이렇게 사용하는 것이 혼동을 줄이고 코드도 깔끔하게 작성 할 수 있다.

# 이것만은 잊지 말자!
- new 표현식에 []를 썼으면, 대응되는 delete에도 []를 써야하고, new에 쓰지 않았다면, delete에도 쓰지 않아야 한다.


 
