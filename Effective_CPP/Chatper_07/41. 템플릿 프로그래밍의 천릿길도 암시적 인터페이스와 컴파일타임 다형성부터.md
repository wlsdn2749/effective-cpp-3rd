객체 지향 프로그래밍의 세계를 회전시키는 축은 **명시적 인터페이스(explicit interface)** 와 **런타임 다형성(runtime polymorphism)** 입니다. 예를 들어 아래의 클래스가 주어졌고

```cpp title:example41.cpp fold
class Widget{
public:
	Widget();
	virtual ~Widget();
	vitual std::size_t size() const;
	virtual void normalize();
	void swap(Widget& other);
};
```

다음의 함수가 있을때

```cpp title:example41_a.cpp fold

void doProcessing(Widget& w)
{
	if(w.size() > 10 && w != someNastyWidget){
		Widget temp(w);
		temp.normalize();
		temp.swap(w);
	}
}
```

w은 Widget타입으로 선언되었기 때문에 w는  Widget의 인터페이스를 지원해야 합니다.
이 인터페이스를 소스 코드 (Widget이 선언된 .h 파일 등)에서 찾으면 이것이 어떤 형태인지를 확인 할 수 있으므로 이런 인터페이스를 **명시적 인터페이스** 라고 한다. 
**(소스코드에 명시적으로 드러나는 인터페이스)**

그리고 
Widget의 멤버 함수 중 몇 개는 가상 함수이므로, 이 가상 함수에 대한 호출은 **런타임 다형성** 에 대해 이루어집니다. 다시 말해, 특정한 함수에 대한 실제 호출은 w의 동적 타입을 기반으로 프로그램 실행 중, 즉 런타임에 결정됩니다.

템플릿과 일반화 프로그래밍에서는 뿌리부터 뭔가 다른 부분이 있는데,
명시적 인터페이스 및 런타임 다형성은 그대로 존재하긴 하지만 중요도가 떨어집니다.
여기서 중요한 것은 **암시적 인터페이스와 컴파일 타임 다형성** 입니다.

"""
명시적 인터페이스 <-> 암시적 인터페이스
런타임 다형성 <-> 컴파일 타임 다형성
"""

만약 아까의 위 doProcessing 함수를 템플릿으로 바꾸면
```cpp title:example41_b.cpp fold

template<typename T>
void doProcessing(T& w)
{
	if(w.size() > 10 && w != someNastyWidget){
		T temp(w);
		temp.normalize();
		temp.swap(w);
	}
}
```

이렇게 변경될 수 있다.
이 템플릿에 안의 w에 대해서 뭐라고 말할 수 있을까?

w가 지원해야하는 인터페이스는 w에 대해 실행되는 연산이 결정한다.
- w.size() : size() 연산을 지원해야하고
- w != someNastyWidget : 부등 비교에 대한 연산도 지원해야하며
- temp(w) : 복사 생성자도 지원해야하고
- normalize, swap(w) : 멤버함수를 지원해야한다.
  
이 템플릿이 제대로 컴파일 되려면 몇 개의 표현식이 유효해야하는데 이 표현식들은 바로 T가 지원해야 하는 암시적 인터페이스라는 점이다.

w가 수반되는 함수 호출이 일어날 때, 이를테면 operator> 및 operator != 함수가 호출될 때에는 해당 호출을 성공시키기 위해 템플릿의 인스턴스화가 일어납니다. 이러한 인스턴스화가 일어나는 시점은 컴파일 도중입니다. 인스턴스화를 진행하는 함수 템플릿에 어떤 탬플릿 메개변수가 들어가느냐에 따라 호출되는 함수가 달라지기 때문에, 이것을 가리켜 컴파일 타임 다형성이라고 한다.

- 런타임 다형성과 컴파일 타임 다형성의 차이는 동적바인딩과 정적바인딩과 상당히 유사하다
  - 컴파일중에 일어나는가? (정적 바인딩)
  - 런타임중에 일어나는가? (동적 바인딩)

명시적 인터페이스와 암시적 인터페이스는 약간 다른데,

명시적 인터페이스는 대개 함수 시그니처로 이루어진다.
시그니처는 함수의 이름, 매개변수 타입, 반환 타입을 통틀어 부르는 용어로 

```cpp title:example41_d.cpp fold
class Widget{
public:
	Widget();
	virtual ~Widget();
	vitual std::size_t size() const;
	virtual void normalize();
	void swap(Widget& other);
};
```
이런 요소요소가 public의 인터페이스가 될 수 있다.


반면 암시적 인터페이스는 약간 다른데,
함수 시그니처에 기반하고 있지 않다는 것이 가장 큰 차이점이 될 수 있다.
암시적 인터페이스를 이루는 요소는 유효 **표현식(expression)** 이다.

doProcessing 템플릿의 시작 부분에 있는 조건문
```cpp title:example41_e.cpp fold
template<typename T>
void doProcessing(T& w)
{
	if(w.size() > 10 && w != someNastyWidget)
	{
	}
}
```

여기서 T(w의 타입)에서 제공될 암시적 인터페이스에는 다음과 같은 제약이 걸린다.

- 정수 계열 값을 반환하고 이름이 size인 함수를 지원해야한다.
- T타입을 비교하는 operator!= 함수를 지원해야한다. )여기서 someNastyWidget은 T라고 가정)

실제로는 연산자 오버로딩의 가능성이 있기 때문에 T는 위 2가지 제약중 어떤것도 만족시킬 필요가 없다.

1. T가 size 멤버함수를 지원해야 하는 것은 맞다
   하지만 수치 타입을 반환할 필요는 없고, operator>의 정의에 필요한 타입도 반환할 필요가 없다.
   그저 operator >가 성립할 수 있도록 X타입의 객체만 반환하면 된다. 또한 operator> 함수는 반드시 X티입의 매개변수를 받아들일 이유가 없는데, 그 이유는 이 함수가 Y타입의 매개변수를 받도록 정의되어있고, X 타입에서 Y타입으로의 암시적인 변환이 가능하다면 되기 때문이다.

2. T가 operator != 함수를 지원해야한다는 것도 아닌데
   operator!= 함수가 X타입의 객체와 Y타입의 객체를 받아들인다고 한다면, 이 부분은 별 걸림돌 없이 넘어갈 수 있기 때문이다. T가 X로 변환될 수 있으며 someNastyWidget의 타입이 Y로 변환되는 것이 가능하다면 operator != 함수 호출은 유효 호출로 간주된다.

단순히 암시적 인터페이스를 이렇게 받아들이면 조금 어려운데, 표현식에 국한되어있다고 생각하면
지극히 평이하다. if문의 조건식 부분은 bool 표현식이어야 하기 때문에, 표현식에 쓰이는것이 어떤 것 인지와는 관계없이,  조건식의 결과값은 bool과 호환되어야 한다. 이 제약이 바로 doProcessing 템플릿이 타입 매개변수인 T에 대해 요구하는 암시적 인터페이스의 일부이다. 

나머지 복사 생성자, normalize, swap 함수도 마찬가지인데, 그 호출이 T타입의 객체에 대해 '유효' 해야한다는 것이다. 어떤 템플릿안에서 어떤 객체를 쓰려고 할때, 그 템플릿에서 요구하는 암시적 인터페이스를 그 객체가 지원하지 않으면 아예 사용이 불가능하다. (컴파일 안됨)

# 이것만은 잊지 말자!
- 클래스 및 템플릿은 모두 인터페이스와 다형성을 지원합니다.
- 클래스의 경우, 인터페이스는 명시적이며 함수의 시그니처르 중심으로 구성되어 있다.
  다형성은 프로그램 실행 중에 가상 함수를 통해 나타낸다.
- 탬플릿 매개변수의 경우, 인터페이스 암시적이며 유효표현식에 기반을 두어 구성된다. 다형성은 컴파일중에 템플릿 인스턴스화와 함수 오버로딩 모호성 해결을 통해 나타난다.