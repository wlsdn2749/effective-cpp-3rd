
`public` data 멤버가 왜 안될까요?

1. 문법적 일관성
	데이터 멤버가 public이 아니라면, 사용자 측에서 어떤 객체를 접근 할 수 있는 유일한 수단은 멤버 함수가 되는데, 그럼 괄호를 붙여야하나 말아야하나 고민없이 그냥 붙이면 되므로 이런 고민을 하는 일이 줄어든다.
2. 함수를 사용하면 데이터 멤버의 접근성에 대해 훨씬 정교한 제어를 할 수 있다.
	만일 어떤 데이터를 public으로 내놨다면, 모두가 이 멤버에 대해 읽기 및 쓰기 권한을 가지게 되지만 이 값을 읽고 쓰는 **함수**가 있다면 **접근 불가**, **읽기 전용**, **읽기 쓰기** 접근을 직접 구현할 수 있다. 심지어 쓰기 전용 접근도 필요하면 구현 가능함.

	```c++
	class AccessLevels{
	public:
		int getReadOnly() const { return readOnly; }
		void setReadWrite(int value) { readWrite = value; }
		int getReadWrite() const { return readWrite; }
		void setWriteOnly(int value) { writeOnly = value; }
	private:
		int noAccess;
		int readOnly;
		int readWrite;
		int writeOnly;
	} 
	```
3. 캡슐화
	함수를 통해서만 데이터 멤버에 접근할 수 있도록 구현하면, 데이터 멤버를 나중에 계산식으로 대체 할 수도 있고, ...

	데이터 멤버를 함수 인터페이스 뒤에 감추게 되면, 구현상의 융통성을 전부 누릴 수 있다. 
	- 데이터 멤버를 쓸 때 다른 객체에 알림 메세지를 보낸다던지
	- 클래스의 불변속성 및 사전조건 및 사후조건을 검증한다던지
	- 스레딩 환경에서 동기화를 건다든지

사용자로부터 데이터 멤버를 숨기면 (캡슐화 하면) 클래스의 불변 속성을 항상 유지하는 데 절대로 소홀해질 수 없게 되는데
-> 데이터의 불변속성을 보여주는게 멤버 함수밖에 없으니까

또한 캡슐화는 현재의 구현을 나중에 바꾸기로 결정할 수 있다.
public 데이터를 건들었다가는 여러 사용자 코드가 깨질 수 있는데
저 public 데이터를 가지고있는 많은 객체가 이에 연결되어 깨지게 되므로 큰 핸들링이 필요하게 된다.
그래서 public은 바꿀 수 없다 란 말과 동치되어 쓰이므로 주의해야한다.
protected도 마찬가지인데, 상속되는 코드가 얼마나 많을지 모르므로 public과 동일하다고 보면 된다.

캡슐화의 관점에서 쓸모 있는 접근 수준은 private(캡슐화 제공), private가 아닌 나머지
이렇게 둘 뿐이라고 말한다.

# 이것만은 잊지 말자
- 데이터 멤버는 private 멤버로 선언하자. 이를 통해 클래스 제작자는 문법적으로 일관성 있는 데이터 접근 통로를 제공 할 수 있고, 필요에 따라서는 세밀한 접근 제어도 가능하며, 클래스의 불변속성을 강화할 수 있을 뿐만 아니라, 내부 구현의 융통성도 발휘할 수 있다.
- protected는 public보다 더 많이 '보호' 받고 있는 것이 절대로 아니다. 어떻게 보면 '보호' 의 관점에서는 public과 protected는 같다.