
```c++
class WebBrowser{
public:
	void clearCache();
	void clearHistory();
	void removeCookies();
	...
	void clearEverything(); 
	// clearCache, clearHistory, removeCookies
	// 를 호출하는 멤버 함수
}

void clearBrowser(WebBrowser& wb) // 를 호출하는 비멤버 함수
{
	wb.clearCache();
	wb.clearHistory();
	wb.removeCookies();	
}
```

어느쪽이 더 나을까요? 
멤버 버전 or 비멤버 버전

결론만 말하자면, 비멤버 버전이 멤버 버전보다 캡슐화 정도가 높으며 
패키징 유연성이 높아지며, 컴파일 의존도도 낮추고 WebBrowser의 확장성도 높일 수 있다는 장점이 있다.

## 캡슐화

외부에서 안에 있는 내용을 볼 수 없다.
밖에서 볼 수 있는 것들이 줄어들면, 그것들을 바꿀 때 필요한 유연성이 커진다.
변경 자체가 영향을 줄 수 있는 범위가 '변경 된 것을 볼 수 있는 것들'로 한정되기 때문에 당연한 것이다.

어떤 객체의 모습을 그 객체의 데이터로 설명할 수 있다면,
이 데이터를 직접 볼 수 있는 코드가 적으면 적을수록 그 데이터는 많이 캡슐화된것이고,
그 객체가 가진 데이터의 특징을 바꿀 수 있는 자유도가 그 만큼 높은 것이다.


private 변수 데이터를 접근하는 함수는 딱 2개인데,
멤버 함수와 프렌드 멤버 함수 개수를 더하면 된다.

근데 굳이 멤버 함수를 써서 객체의 여러곳에 접근가능하도록 캡슐화를 낮춘다면
그건 좋은 설계가 아닐 것이다. 같은 기능을 하는것이 자명하다면 비멤버 비프렌드 함수로
이를 외부로 빼면 보다 더 좋은 설계로 캡슐화를 높일 수 있다.

비멤버 함수에 2가지 유의할 점은
1. 비프렌드 함수에만 적용된다.
	프렌드 함수는 private 멤버에 대한 접근 권한이 해당 클래스의 멤버함수가 가진 접근권한과 똑같기 때문에, 캡슐화에 대한 영향이 같다.
2. "함수는 어떤 클래스의 비멤버가 되어야 한다." 라는 주장이 "그 함수는 다른 클래스의 멤버가 될 수 없다." 라는 의미가 아님
   clearBrowser함수를 다른 유틸리티 클래스에 정적 멤버 함수로 만들어도 된다.
   이 함수가 WebBroswer의 멤버이거나 프렌드만 아니면 된다.

namespace...


# 이것만은 잊지 말자!
- 멤버 함수보다는 비멤버 비프렌드 함수를 자주 쓰도록 하자. 캡슐화 정도가 높아지고, 패키징 유연성도 커지며, 기능적인 확장성도 늘어난다.